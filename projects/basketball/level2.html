<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Rapid Fire Free Throws — Level 2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #f2f6ff, #d7e1ff 55%, #a4b5ff);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem 1rem 3rem;
    }

    main {
      max-width: 960px;
      width: 100%;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(6px);
      border-radius: 18px;
      box-shadow: 0 24px 40px rgba(40, 52, 120, 0.25);
      padding: 2rem clamp(1rem, 3vw, 2.5rem) 3rem;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      font-weight: 600;
      margin-bottom: 1.5rem;
      color: #2f3d86;
      text-decoration: none;
      transition: transform 0.15s ease, color 0.15s ease;
    }

    .back-link:hover,
    .back-link:focus {
      color: #ff6c3c;
      transform: translateX(-3px);
    }

    .level-nav {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem 1.2rem;
      margin-bottom: 1.5rem;
      font-weight: 600;
      color: #1f2b5c;
    }

    .level-link {
      position: relative;
      padding: 0.4rem 1.2rem;
      border-radius: 999px;
      background: rgba(63, 79, 155, 0.16);
      color: inherit;
      text-decoration: none;
      transition: transform 0.15s ease, background 0.15s ease;
    }

    .level-link:hover,
    .level-link:focus {
      transform: translateY(-2px);
      background: rgba(255, 108, 60, 0.18);
      outline: none;
    }

    .level-link--current {
      background: linear-gradient(135deg, rgba(255, 120, 44, 0.9), rgba(255, 78, 78, 0.9));
      color: #fff;
      box-shadow: 0 14px 24px rgba(240, 80, 40, 0.28);
    }

    .level-link--locked {
      opacity: 0.45;
      pointer-events: none;
      background: rgba(102, 112, 166, 0.22);
      color: rgba(32, 42, 92, 0.7);
      box-shadow: none;
    }

    .level-lock-text {
      font-size: 0.95rem;
      color: rgba(41, 58, 122, 0.9);
    }

    .level-lock-text strong {
      font-weight: 700;
    }

    .level-lock-banner {
      margin: 0 0 1rem;
      padding: 0.85rem 1rem;
      border-radius: 12px;
      background: rgba(63, 79, 155, 0.12);
      color: #1f2b5c;
      font-weight: 600;
    }

    h1 {
      font-size: clamp(2.2rem, 3vw + 1rem, 3.2rem);
      text-align: center;
      margin-top: 0;
      letter-spacing: 0.04em;
      color: #293a7a;
      text-shadow: 0 6px 16px rgba(25, 40, 92, 0.35);
    }

    #hud {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 1rem 2rem;
      margin-bottom: 1.5rem;
      font-weight: 600;
      color: #1f2b5c;
    }

    #hud span {
      min-width: 140px;
      text-align: center;
      font-size: 1.05rem;
    }

    #hud button {
      appearance: none;
      border: none;
      padding: 0.85rem 2.4rem;
      border-radius: 999px;
      font-size: 1.1rem;
      font-weight: 700;
      color: #fff;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, filter 0.18s ease;
    }

    #hud button:disabled {
      cursor: not-allowed;
      filter: grayscale(40%);
      box-shadow: none;
    }

    #shoot {
      background: linear-gradient(135deg, #ff782c, #ff4e4e);
      box-shadow: 0 18px 24px rgba(240, 80, 40, 0.3);
    }

    #shoot:disabled {
      background: #ffb48d;
      color: rgba(255, 255, 255, 0.8);
    }

    #shoot:not(:disabled):hover {
      transform: translateY(-2px);
      box-shadow: 0 20px 28px rgba(240, 80, 40, 0.35);
    }

    #stop {
      background: linear-gradient(135deg, #4f67ff, #3849d7);
      box-shadow: 0 18px 24px rgba(60, 82, 220, 0.3);
    }

    #stop:disabled {
      background: #9ba5ff;
      color: rgba(255, 255, 255, 0.85);
    }

    #stop:not(:disabled):hover {
      transform: translateY(-2px);
      box-shadow: 0 20px 28px rgba(60, 82, 220, 0.35);
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
      border: 2px solid rgba(25, 40, 92, 0.15);
      background: linear-gradient(#9acbff, #87b7ff);
    }

    canvas.board-enabled {
      cursor: grab;
    }

    canvas.board-enabled.board-dragging {
      cursor: grabbing;
    }

    .court-wrapper {
      position: relative;
    }

    #score-flash {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(2.4rem, 5vw, 3.6rem);
      font-weight: 800;
      color: rgba(255, 255, 255, 0.96);
      text-shadow: 0 10px 22px rgba(25, 30, 60, 0.45);
      background: radial-gradient(circle, rgba(22, 32, 78, 0.35), rgba(22, 32, 78, 0));
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    #score-flash.visible {
      opacity: 1;
    }

    #controls {
      display: grid;
      gap: 0.8rem 1.2rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      margin-bottom: 1.4rem;
      color: #1f2b5c;
      font-weight: 600;
    }

    #controls label {
      display: grid;
      gap: 0.35rem;
      font-size: 0.95rem;
      padding: 0.9rem 1rem;
      border-radius: 12px;
      background: rgba(71, 92, 156, 0.08);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    #controls input[type="range"] {
      width: 100%;
      accent-color: #ff6c3c;
    }

    #controls span {
      font-size: 0.9rem;
      color: #293a7a;
    }

    p {
      margin-top: 1.75rem;
      line-height: 1.6;
      color: #2b3570;
      text-align: center;
    }

    .level-intro {
      margin: 0 0 1.3rem;
      text-align: left;
      font-size: 1.05rem;
      color: #1f2b5c;
    }

    #run-history {
      margin-top: 2.6rem;
    }

    #run-history h2 {
      font-size: clamp(1.4rem, 2vw + 1rem, 1.9rem);
      color: #24316d;
      text-align: center;
      margin-bottom: 1.1rem;
    }

    #run-history table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(255, 255, 255, 0.86);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 12px 22px rgba(32, 44, 98, 0.14);
    }

    #run-history th,
    #run-history td {
      padding: 0.75rem 0.9rem;
      font-size: 0.95rem;
      text-align: left;
      color: #1f2b5c;
    }

    #run-history thead {
      background: linear-gradient(135deg, rgba(76, 99, 196, 0.95), rgba(56, 73, 175, 0.95));
      color: #fff;
    }

    #run-history tbody tr:nth-child(even) {
      background: rgba(132, 148, 220, 0.08);
    }

    #run-history tbody tr:hover {
      background: rgba(255, 193, 126, 0.25);
    }

    #run-history td:last-child {
      font-weight: 700;
    }
  </style>
</head>
<body>
  <main>
    <a class="back-link" href="/index.html" aria-label="Back to projects">
      <span aria-hidden="true">⟵</span>
      Back to projects
    </a>
    <h1>Rapid Fire Free Throws</h1>
    <nav class="level-nav" aria-label="Basketball levels">
      <span>Levels:</span>
      <a class="level-link" href="./">Level 1</a>
      <a id="level2-link" class="level-link level-link--current" href="./level2.html">Level 2</a>
      <span id="level2-lock-text" class="level-lock-text">Reach 90 on Level 1 to unlock this level.</span>
    </nav>
    <p id="level2-locked-message" class="level-lock-banner" hidden>
      Score 90 or more on Level 1 to unlock this advanced drill. Your best runs will appear here once unlocked.
    </p>
    <div id="hud">
      <span id="score">Score: 0</span>
      <span id="balls">Balls in play: 0</span>
      <span id="timer">Timer: 0.0s</span>
      <button id="shoot">Start Shooting</button>
      <button id="stop" disabled>Stop</button>
    </div>
    <p class="level-intro">
      Level 2: the practice court added a roaming backboard. Drag it with your pointer or nudge it with WASD/arrow keys
      to send ricocheting shots into the hoop. Keep your rhythm—balls still launch for ten frantic seconds.
    </p>
    <div id="controls">
      <label for="angle-control">
        Angle boost
        <input type="range" id="angle-control" min="-0.25" max="0.83" step="0.01" value="0.18" />
        <span id="angle-display">+10.3°</span>
      </label>
      <label for="power-control">
        Launch power
        <input type="range" id="power-control" min="14" max="39" step="0.1" value="19.5" />
        <span id="power-display">19.5 u/s</span>
      </label>
    </div>
    <div class="court-wrapper">
      <canvas id="court" width="960" height="540"></canvas>
      <div id="score-flash" role="status" aria-live="polite"></div>
    </div>
    <p>Unleash a cascade of free throws! Hit the button to fire 20 balls a second for ten straight seconds. Shots ricochet off the floor, the wall, and even each other. Sink them through the hoop before time runs out.</p>
    <section id="run-history">
      <h2>Top 10 Runs</h2>
      <table>
        <thead>
          <tr>
            <th scope="col">Rank</th>
            <th scope="col">Timestamp</th>
            <th scope="col">Angle Boost</th>
            <th scope="col">Launch Power</th>
            <th scope="col">Spawn Rate</th>
            <th scope="col">Duration</th>
            <th scope="col">Score</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </main>

  <script>
    (() => {
      const canvas = document.getElementById('court');
      const gl = canvas.getContext('webgl2');
      const hudScore = document.getElementById('score');
      const hudBalls = document.getElementById('balls');
      const hudTimer = document.getElementById('timer');
      const shootButton = document.getElementById('shoot');
      const stopButton = document.getElementById('stop');
      const angleSlider = document.getElementById('angle-control');
      const powerSlider = document.getElementById('power-control');
      const angleDisplay = document.getElementById('angle-display');
      const powerDisplay = document.getElementById('power-display');
      const historyBody = document.querySelector('#run-history tbody');
      const scoreFlash = document.getElementById('score-flash');
      const level2Link = document.getElementById('level2-link');
      const level2LockText = document.getElementById('level2-lock-text');
      const lockBanner = document.getElementById('level2-locked-message');

      const HISTORY_COOKIE = 'rapid_fire_runs_level2_v1';
      const LEVEL_ONE_COOKIE = 'rapid_fire_runs_level1_v1';
      const MAX_HISTORY = 10;
      const UNLOCK_STORAGE_KEY = 'rapid_fire_free_throws_level2_unlocked';
      const unlockThreshold = 90;

      if (!gl) {
        shootButton.disabled = true;
        stopButton.disabled = true;
        canvas.replaceWith(Object.assign(document.createElement('p'), {
          textContent: 'WebGL2 is required to run this demo. Please try a modern browser!'
        }));
        return;
      }

      const worldWidth = 28;
      const worldHeight = 16;
      const gravity = -24;
      const floorHeight = 0.85;
      const floorY = floorHeight;
      const hoop = {
        x: 23.5,
        y: 9.6,
        radius: 0.95,
        innerRatio: 0.68,
        color: [0.85, 0.1, 0.1, 1.0]
      };
      const spawn = { x: 5, y: floorY + 1.65 };
      const wallRestitution = 0.76;
      const ballRestitution = 0.84;
      const spawnRate = 20;
      const spawnInterval = 1000 / spawnRate;
      const runDurationMs = 10000;
      const simulationDurationMs = 10300;
      const ballRadius = 0.36;

      const boardAspect = 264 / 8000;
      const board = {
        width: 11.5,
        height: 11.5 * boardAspect,
        x: 19.2,
        y: 8.4,
        speed: 13,
        restitution: 0.92,
        padding: 0.6,
        verticalPadding: 0.6,
        texture: null,
        locked: true,
        pointerId: null,
        offsetX: 0,
        offsetY: 0,
        pressedKeys: new Set()
      };

      const balls = [];
      let score = 0;
      let shootStart = 0;
      let shootEnd = 0;
      let simulationEnd = 0;
      let lastSpawn = 0;
      let lastFrame = 0;
      let animationActive = false;
      let animationFrameId = null;
      let currentRun = null;
      let runHistory = loadHistory();
      let levelUnlocked = false;
      let flashTimeoutId = null;

      const circleGeometry = createCircleGeometry(gl, 48);
      const circleProgram = createCircleProgram(gl, circleGeometry);
      const rectProgram = createRectProgram(gl);
      const textureProgram = createTextureProgram(gl);
      const instanceBuffer = gl.createBuffer();

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      canvas.classList.add('board-enabled');
      canvas.style.touchAction = 'none';

      loadBoardTexture('assets/board.png');
      setupBoardControls();

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      updateControls();
      renderHistory();
      levelUnlocked = updateLevelUnlockState();
      renderScene();
      updateHud(performance.now());
      hideScoreFlash();

      shootButton.addEventListener('click', startNewRun);
      stopButton.addEventListener('click', () => finalizeRun('canceled'));

      angleSlider.addEventListener('input', () => {
        updateControls();
        if (currentRun && currentRun.state === 'running') {
          currentRun.params.angleBoost = parseFloat(angleSlider.value);
        }
      });

      powerSlider.addEventListener('input', () => {
        updateControls();
        if (currentRun && currentRun.state === 'running') {
          currentRun.params.launchPower = parseFloat(powerSlider.value);
        }
      });

      function startNewRun() {
        if (board.locked) {
          return;
        }

        const now = performance.now();

        if (currentRun && currentRun.state === 'running') {
          finalizeRun('canceled', now);
        }

        const initialAngle = parseFloat(angleSlider.value);
        const initialPower = parseFloat(powerSlider.value);

        balls.length = 0;
        score = 0;
        shootStart = now;
        shootEnd = shootStart + runDurationMs;
        simulationEnd = shootStart + simulationDurationMs;
        lastSpawn = shootStart;
        lastFrame = shootStart;
        animationActive = true;

        currentRun = {
          state: 'running',
          startedAt: now,
          params: {
            angleBoost: initialAngle,
            launchPower: initialPower,
            spawnRate,
            duration: simulationDurationMs / 1000
          }
        };

        shootButton.disabled = true;
        stopButton.disabled = false;
        hideScoreFlash();
        updateHud(now);
        renderScene();

        if (animationFrameId !== null) {
          cancelAnimationFrame(animationFrameId);
        }
        animationFrameId = requestAnimationFrame(loop);
      }

      function spawnBall(time) {
        const angleAdjustment = parseFloat(angleSlider.value);
        const baseSpeed = parseFloat(powerSlider.value);
        const angleOffset = (Math.random() - 0.5) * 0.24;
        const baseTargetX = hoop.x - spawn.x;
        const baseTargetY = (hoop.y + 1.1) - spawn.y;
        const baseAngle = Math.atan2(baseTargetY, baseTargetX) + angleAdjustment;
        const angle = baseAngle + angleOffset;
        const directionX = Math.cos(angle);
        const directionY = Math.sin(angle);
        const speed = baseSpeed + (Math.random() - 0.5) * 3.0;
        const newBall = {
          x: spawn.x + (Math.random() - 0.5) * 0.28,
          y: spawn.y + (Math.random() - 0.1) * 0.14,
          vx: directionX * speed + (Math.random() - 0.5) * 2.2,
          vy: directionY * speed + Math.random() * 1.4,
          radius: ballRadius * (0.95 + Math.random() * 0.1),
          active: true
        };
        balls.push(newBall);
        updateHud(time);
      }

      function updateHud(time) {
        hudScore.textContent = `Score: ${score}`;
        hudBalls.textContent = `Balls in play: ${balls.filter(b => b.active).length}`;
        const remaining = Math.max(0, (simulationEnd - time) / 1000);
        hudTimer.textContent = `Timer: ${remaining.toFixed(1)}s`;
      }

      function updateControls() {
        const angleValue = parseFloat(angleSlider.value);
        const powerValue = parseFloat(powerSlider.value);
        const angleDegrees = angleValue * (180 / Math.PI);
        const formattedAngle = `${angleDegrees >= 0 ? '+' : ''}${angleDegrees.toFixed(1)}°`;
        angleDisplay.textContent = formattedAngle;
        powerDisplay.textContent = `${powerValue.toFixed(1)} u/s`;
      }

      function updatePhysics(dt, now) {
        const activeBalls = balls.filter(b => b.active);

        updateBoardFromKeys(dt);

        for (const ball of activeBalls) {
          ball.vy += gravity * dt;
          ball.x += ball.vx * dt;
          ball.y += ball.vy * dt;

          if (ball.y - ball.radius < floorY) {
            ball.y = floorY + ball.radius;
            ball.vy = Math.abs(ball.vy) * wallRestitution;
            ball.vx *= 0.88;
          }
          const rightWall = worldWidth - 0.4;
          if (ball.x - ball.radius < 0.4) {
            ball.x = 0.4 + ball.radius;
            ball.vx = Math.abs(ball.vx) * wallRestitution;
          }
          if (ball.x + ball.radius > rightWall) {
            ball.x = rightWall - ball.radius;
            ball.vx = -Math.abs(ball.vx) * wallRestitution;
          }
          const ceiling = worldHeight - 0.3;
          if (ball.y + ball.radius > ceiling) {
            ball.y = ceiling - ball.radius;
            ball.vy = -Math.abs(ball.vy) * 0.65;
          }

          handleBoardCollision(ball);

          const dx = ball.x - hoop.x;
          const dy = ball.y - hoop.y;
          const distSq = dx * dx + dy * dy;
          if (distSq < (hoop.radius - ball.radius * 0.35) * (hoop.radius - ball.radius * 0.35)) {
            ball.active = false;
            score += 1;
          }
        }

        for (let i = 0; i < activeBalls.length; i++) {
          const a = activeBalls[i];
          for (let j = i + 1; j < activeBalls.length; j++) {
            const b = activeBalls[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const distSq = dx * dx + dy * dy;
            const minDist = a.radius + b.radius;
            if (distSq > minDist * minDist) continue;
            const distance = Math.sqrt(distSq) || minDist;
            const nx = dx / distance;
            const ny = dy / distance;
            const penetration = minDist - distance;
            const correction = penetration / 2;
            a.x -= nx * correction;
            a.y -= ny * correction;
            b.x += nx * correction;
            b.y += ny * correction;

            const rvx = b.vx - a.vx;
            const rvy = b.vy - a.vy;
            const velAlongNormal = rvx * nx + rvy * ny;
            if (velAlongNormal > 0) continue;
            const impulse = -(1 + ballRestitution) * velAlongNormal / 2;
            const impulseX = impulse * nx;
            const impulseY = impulse * ny;
            a.vx -= impulseX;
            a.vy -= impulseY;
            b.vx += impulseX;
            b.vy += impulseY;
          }
        }

        for (const ball of activeBalls) {
          ball.vx *= 0.999;
          ball.vy *= 0.999;
        }

        for (let i = balls.length - 1; i >= 0; i--) {
          if (!balls[i].active) {
            balls.splice(i, 1);
          }
        }

        updateHud(now);
      }

      function loop(now) {
        if (!animationActive || !currentRun || currentRun.state !== 'running') {
          animationFrameId = null;
          return;
        }

        if (!lastFrame) lastFrame = now;
        const dt = Math.min(0.05, (now - lastFrame) / 1000);

        if (now < shootEnd) {
          while (lastSpawn <= now) {
            spawnBall(now);
            lastSpawn += spawnInterval;
          }
        }

        updatePhysics(dt, now);
        renderScene();
        lastFrame = now;

        if (!animationActive || !currentRun || currentRun.state !== 'running') {
          animationFrameId = null;
          return;
        }

        if (now >= simulationEnd) {
          animationFrameId = null;
          finalizeRun('completed', now);
          return;
        }

        animationFrameId = requestAnimationFrame(loop);
      }

      function finalizeRun(outcome, time = performance.now()) {
        if (!currentRun || currentRun.state !== 'running') {
          return;
        }

        const record = {
          timestamp: new Date().toISOString(),
          angleBoost: currentRun.params.angleBoost,
          launchPower: currentRun.params.launchPower,
          spawnRate: currentRun.params.spawnRate,
          duration: currentRun.params.duration,
          score: outcome === 'completed' ? score : null,
          status: outcome
        };

        addRunRecord(record);
        saveHistory(runHistory);
        renderHistory();
        levelUnlocked = updateLevelUnlockState();

        currentRun.state = outcome;
        currentRun = null;
        animationActive = false;
        if (animationFrameId !== null) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        balls.length = 0;
        lastSpawn = 0;
        lastFrame = 0;
        shootButton.disabled = !levelUnlocked;
        stopButton.disabled = true;
        shootEnd = 0;
        simulationEnd = time;
        updateHud(time);
        renderScene();

        if (outcome === 'completed') {
          showScoreFlash(score);
        } else {
          hideScoreFlash();
        }
      }

      function renderScene() {
        resizeCanvas();
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.54, 0.73, 0.95, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        drawRect(0, 0, worldWidth, floorHeight, [0.91, 0.6, 0.26, 1.0]);
        drawRect(0, Math.max(0, floorHeight - 0.16), worldWidth, 0.16, [0.75, 0.48, 0.2, 1.0]);
        drawRect(0, 0, 0.4, worldHeight, [0.82, 0.85, 0.92, 1]);
        drawRect(22.8, 7.8, 0.16, 4.2, [0.7, 0.7, 0.76, 1]);
        drawRect(22.96, 10.3, 0.7, 2.2, [0.96, 0.96, 0.98, 1]);
        drawRect(23.1, 10.55, 0.42, 1.7, [0.88, 0.9, 0.96, 1]);

        if (board.texture) {
          drawTexturedRect(board);
        } else {
          drawRect(board.x - board.width / 2, board.y - board.height / 2, board.width, board.height, [0.9, 0.9, 0.95, 0.8]);
        }

        drawCircle(hoop.x, hoop.y, hoop.radius, hoop.innerRatio, hoop.color);

        const playerFootY = floorY + 0.05;
        const playerBodyColor = [0.1, 0.18, 0.3, 1];
        drawRect(spawn.x - 1.3, playerFootY, 0.22, 1.35, playerBodyColor);
        drawRect(spawn.x - 0.88, playerFootY, 0.22, 1.32, playerBodyColor);
        const playerTorsoY = playerFootY + 1.28;
        drawRect(spawn.x - 1.28, playerTorsoY, 0.86, 1.18, playerBodyColor);
        drawRect(spawn.x - 1.68, playerTorsoY + 0.72, 0.72, 0.16, playerBodyColor);
        drawRect(spawn.x - 0.5, playerTorsoY + 0.62, 0.96, 0.16, playerBodyColor);
        drawCircle(spawn.x - 0.88, playerTorsoY + 1.65, 0.55, -1, [0.99, 0.89, 0.72, 1]);

        if (balls.length) {
          const instanceData = new Float32Array(balls.length * 8);
          for (let i = 0; i < balls.length; i++) {
            const ball = balls[i];
            instanceData[i * 8 + 0] = ball.x;
            instanceData[i * 8 + 1] = ball.y;
            instanceData[i * 8 + 2] = ball.radius;
            instanceData[i * 8 + 3] = -1;
            instanceData[i * 8 + 4] = 1.0;
            instanceData[i * 8 + 5] = 0.5;
            instanceData[i * 8 + 6] = 0.0;
            instanceData[i * 8 + 7] = 1.0;
          }
          gl.useProgram(circleProgram.program);
          gl.bindVertexArray(circleProgram.vao);
          gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.DYNAMIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 0);
          gl.vertexAttribDivisor(1, 1);
          gl.enableVertexAttribArray(2);
          gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 32, 8);
          gl.vertexAttribDivisor(2, 1);
          gl.enableVertexAttribArray(3);
          gl.vertexAttribPointer(3, 1, gl.FLOAT, false, 32, 12);
          gl.vertexAttribDivisor(3, 1);
          gl.enableVertexAttribArray(4);
          gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 32, 16);
          gl.vertexAttribDivisor(4, 1);
          gl.uniform2f(circleProgram.uniforms.uWorldSize, worldWidth, worldHeight);
          gl.drawArraysInstanced(gl.TRIANGLE_FAN, 0, circleGeometry.count, balls.length);
          gl.bindVertexArray(null);
        }
      }

      function drawCircle(x, y, radius, innerRatio, color) {
        gl.useProgram(circleProgram.program);
        gl.bindVertexArray(circleProgram.vao);
        const instance = new Float32Array([
          x,
          y,
          radius,
          innerRatio,
          color[0],
          color[1],
          color[2],
          color[3]
        ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, instance, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 0);
        gl.vertexAttribDivisor(1, 1);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 32, 8);
        gl.vertexAttribDivisor(2, 1);
        gl.enableVertexAttribArray(3);
        gl.vertexAttribPointer(3, 1, gl.FLOAT, false, 32, 12);
        gl.vertexAttribDivisor(3, 1);
        gl.enableVertexAttribArray(4);
        gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 32, 16);
        gl.vertexAttribDivisor(4, 1);
        gl.uniform2f(circleProgram.uniforms.uWorldSize, worldWidth, worldHeight);
        gl.drawArraysInstanced(gl.TRIANGLE_FAN, 0, circleGeometry.count, 1);
        gl.bindVertexArray(null);
      }

      function drawRect(x, y, width, height, color) {
        gl.useProgram(rectProgram.program);
        gl.bindVertexArray(rectProgram.vao);
        const x2 = x + width;
        const y2 = y + height;
        const vertices = new Float32Array([
          x, y,
          x2, y,
          x, y2,
          x2, y,
          x2, y2,
          x, y2
        ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, rectProgram.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        gl.uniform2f(rectProgram.uniforms.uWorldSize, worldWidth, worldHeight);
        gl.uniform4f(rectProgram.uniforms.uColor, color[0], color[1], color[2], color[3]);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.bindVertexArray(null);
      }

      function drawTexturedRect(boardState) {
        if (!boardState.texture) return;
        gl.useProgram(textureProgram.program);
        gl.bindVertexArray(textureProgram.vao);
        const halfW = boardState.width / 2;
        const halfH = boardState.height / 2;
        const left = boardState.x - halfW;
        const right = boardState.x + halfW;
        const bottom = boardState.y - halfH;
        const top = boardState.y + halfH;
        const vertices = new Float32Array([
          left, bottom, 0, 0,
          right, bottom, 1, 0,
          left, top, 0, 1,
          right, bottom, 1, 0,
          right, top, 1, 1,
          left, top, 0, 1
        ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, textureProgram.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, boardState.texture);
        gl.uniform2f(textureProgram.uniforms.uWorldSize, worldWidth, worldHeight);
        gl.uniform1i(textureProgram.uniforms.uSampler, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.bindVertexArray(null);
      }

      function addRunRecord(record) {
        runHistory.push(record);
        runHistory = sortHistory(runHistory);
        if (runHistory.length > MAX_HISTORY) {
          runHistory.length = MAX_HISTORY;
        }
      }

      function sortHistory(records) {
        return records
          .slice()
          .sort((a, b) => {
            const scoreDiff = sortScore(b) - sortScore(a);
            if (scoreDiff !== 0) {
              return scoreDiff;
            }
            const aTime = Date.parse(a.timestamp);
            const bTime = Date.parse(b.timestamp);
            if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
              return 0;
            }
            if (Number.isNaN(aTime)) {
              return 1;
            }
            if (Number.isNaN(bTime)) {
              return -1;
            }
            return bTime - aTime;
          });
      }

      function sortScore(record) {
        return Number.isFinite(record?.score) ? record.score : -Infinity;
      }

      function renderHistory() {
        historyBody.innerHTML = '';
        if (!runHistory.length) {
          const row = document.createElement('tr');
          const cell = document.createElement('td');
          cell.colSpan = 7;
          cell.textContent = 'No runs recorded yet. Play a round to see your stats!';
          cell.style.textAlign = 'center';
          row.appendChild(cell);
          historyBody.appendChild(row);
          return;
        }

        runHistory.forEach((record, index) => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${index + 1}</td>
            <td>${formatTimestamp(record.timestamp)}</td>
            <td>${formatAngle(record.angleBoost)}</td>
            <td>${formatLaunchPower(record.launchPower)}</td>
            <td>${formatSpawnRate(record.spawnRate)}</td>
            <td>${formatDuration(record.duration)}</td>
            <td>${formatScore(record)}</td>
          `;
          historyBody.appendChild(row);
        });
      }

      function formatTimestamp(timestamp) {
        const parsed = Date.parse(timestamp);
        if (Number.isNaN(parsed)) {
          return timestamp;
        }
        return new Date(parsed).toLocaleString();
      }

      function formatAngle(angleRad) {
        const safeAngle = Number.isFinite(angleRad) ? angleRad : 0;
        const degrees = safeAngle * (180 / Math.PI);
        const sign = degrees >= 0 ? '+' : '';
        return `${sign}${degrees.toFixed(1)}°`;
      }

      function formatLaunchPower(power) {
        const value = Number.isFinite(power) ? power : 0;
        return `${value.toFixed(1)} u/s`;
      }

      function formatSpawnRate(rate) {
        const value = Number.isFinite(rate) ? rate : spawnRate;
        return `${Math.round(value)} balls/s`;
      }

      function formatDuration(durationSeconds) {
        const value = Number.isFinite(durationSeconds) ? durationSeconds : simulationDurationMs / 1000;
        return `${value.toFixed(1)} s`;
      }

      function formatScore(record) {
        return Number.isFinite(record?.score) ? record.score : 'CANCELED';
      }

      function loadHistory() {
        const raw = getCookie(HISTORY_COOKIE);
        if (!raw) {
          return [];
        }
        try {
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) {
            return [];
          }
          const normalized = parsed
            .map(normalizeRecord)
            .filter(Boolean);
          return sortHistory(normalized).slice(0, MAX_HISTORY);
        } catch (error) {
          console.warn('Unable to parse saved runs', error);
          return [];
        }
      }

      function normalizeRecord(entry) {
        if (!entry || typeof entry !== 'object') {
          return null;
        }
        const timestamp = typeof entry.timestamp === 'string' ? entry.timestamp : null;
        if (!timestamp) {
          return null;
        }
        const angleBoost = Number(entry.angleBoost);
        const launchPower = Number(entry.launchPower);
        const rate = Number(entry.spawnRate);
        const duration = Number(entry.duration);
        const status = entry.status === 'completed' ? 'completed' : 'canceled';
        const scoreValue = Number(entry.score);
        return {
          timestamp,
          angleBoost: Number.isFinite(angleBoost) ? angleBoost : 0,
          launchPower: Number.isFinite(launchPower) ? launchPower : 0,
          spawnRate: Number.isFinite(rate) && rate > 0 ? Math.round(rate) : spawnRate,
          duration: Number.isFinite(duration) && duration > 0 ? duration : simulationDurationMs / 1000,
          score: status === 'completed' && Number.isFinite(scoreValue) ? Math.max(0, Math.floor(scoreValue)) : null,
          status
        };
      }

      function saveHistory(records) {
        try {
          setCookie(HISTORY_COOKIE, JSON.stringify(records.slice(0, MAX_HISTORY)));
        } catch (error) {
          console.warn('Unable to save run history', error);
        }
      }

      function setCookie(name, value, days = 365) {
        const maxAge = Math.floor(days * 24 * 60 * 60);
        document.cookie = `${name}=${encodeURIComponent(value)};max-age=${maxAge};path=/;SameSite=Lax`;
      }

      function getCookie(name) {
        const escapedName = name.replace(/([.*+?^${}()|[\\]\\])/g, '\\$1');
        const match = document.cookie.match(new RegExp(`(?:^|; )${escapedName}=([^;]*)`));
        return match ? decodeURIComponent(match[1]) : null;
      }

      function getBestScore() {
        return runHistory.reduce((best, record) => {
          if (Number.isFinite(record?.score) && record.score > best) {
            return record.score;
          }
          return best;
        }, -Infinity);
      }

      function getLevelOneBestScore() {
        const raw = getCookie(LEVEL_ONE_COOKIE);
        if (!raw) {
          return -Infinity;
        }
        try {
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) {
            return -Infinity;
          }
          return parsed.reduce((best, entry) => {
            const value = Number(entry?.score);
            if (Number.isFinite(value) && value > best) {
              return Math.floor(value);
            }
            return best;
          }, -Infinity);
        } catch (error) {
          return -Infinity;
        }
      }

      function getStoredUnlockFlag() {
        try {
          return localStorage.getItem(UNLOCK_STORAGE_KEY) === 'true';
        } catch (error) {
          return false;
        }
      }

      function setStoredUnlockFlag(value) {
        try {
          if (value) {
            localStorage.setItem(UNLOCK_STORAGE_KEY, 'true');
          } else {
            localStorage.removeItem(UNLOCK_STORAGE_KEY);
          }
        } catch (error) {
          // ignore storage issues
        }
      }

      function updateLevelUnlockState() {
        const levelOneBest = getLevelOneBestScore();
        const unlockedFromScore = Number.isFinite(levelOneBest) && levelOneBest >= unlockThreshold;
        const unlockedFromStorage = getStoredUnlockFlag();
        const unlocked = unlockedFromScore || unlockedFromStorage;

        if (unlockedFromScore && !unlockedFromStorage) {
          setStoredUnlockFlag(true);
        }

        if (level2LockText) {
          level2LockText.textContent = unlocked
            ? 'Level 2 unlocked! Guide the board to redirect shots.'
            : `Reach ${unlockThreshold}+ on Level 1 to unlock this level.`;
        }

        if (lockBanner) {
          lockBanner.hidden = unlocked;
        }

        board.locked = !unlocked;

        if (!unlocked) {
          shootButton.disabled = true;
          stopButton.disabled = true;
          hideScoreFlash();
        } else if (!currentRun) {
          shootButton.disabled = false;
          stopButton.disabled = true;
        }

        return unlocked;
      }

      function showScoreFlash(value) {
        if (!scoreFlash) return;
        if (flashTimeoutId !== null) {
          clearTimeout(flashTimeoutId);
        }
        scoreFlash.textContent = `Score: ${value}`;
        scoreFlash.classList.add('visible');
        flashTimeoutId = window.setTimeout(() => {
          flashTimeoutId = null;
          hideScoreFlash();
        }, 1500);
      }

      function hideScoreFlash() {
        if (!scoreFlash) return;
        scoreFlash.classList.remove('visible');
        if (flashTimeoutId !== null) {
          clearTimeout(flashTimeoutId);
          flashTimeoutId = null;
        }
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = Math.floor(canvas.clientWidth * dpr);
        const displayHeight = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
        }
      }

      function createCircleProgram(gl, geometry) {
        const vertexSource = `#version 300 es\nlayout(location = 0) in vec2 aVertex;\nlayout(location = 1) in vec2 aCenter;\nlayout(location = 2) in float aRadius;\nlayout(location = 3) in float aInnerRatio;\nlayout(location = 4) in vec4 aColor;\nuniform vec2 uWorldSize;\nout vec2 vLocal;\nout float vInnerRatio;\nout vec4 vColor;\nvoid main() {\n  vec2 worldPos = aCenter + aVertex * aRadius;\n  vec2 normalized = worldPos / uWorldSize;\n  vec2 clip = normalized * 2.0 - 1.0;\n  vLocal = aVertex;\n  vInnerRatio = aInnerRatio;\n  vColor = aColor;\n  gl_Position = vec4(clip, 0.0, 1.0);\n}`;
        const fragmentSource = `#version 300 es\nprecision highp float;\nin vec2 vLocal;\nin float vInnerRatio;\nin vec4 vColor;\nout vec4 outColor;\nvoid main() {\n  float dist = length(vLocal);\n  if (dist > 1.0) discard;\n  if (vInnerRatio >= 0.0 && dist < vInnerRatio) discard;\n  outColor = vColor;\n}`;
        const program = buildProgram(gl, vertexSource, fragmentSource);
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        gl.bindVertexArray(null);
        const uniforms = {
          uWorldSize: gl.getUniformLocation(program, 'uWorldSize')
        };
        return { program, vao, uniforms };
      }

      function createRectProgram(gl) {
        const vertexSource = `#version 300 es\nlayout(location = 0) in vec2 aPosition;\nuniform vec2 uWorldSize;\nvoid main() {\n  vec2 normalized = aPosition / uWorldSize;\n  vec2 clip = normalized * 2.0 - 1.0;\n  gl_Position = vec4(clip, 0.0, 1.0);\n}`;
        const fragmentSource = `#version 300 es\nprecision mediump float;\nuniform vec4 uColor;\nout vec4 outColor;\nvoid main() {\n  outColor = uColor;\n}`;
        const program = buildProgram(gl, vertexSource, fragmentSource);
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        gl.bindVertexArray(null);
        const uniforms = {
          uWorldSize: gl.getUniformLocation(program, 'uWorldSize'),
          uColor: gl.getUniformLocation(program, 'uColor')
        };
        return { program, vao, buffer, uniforms };
      }

      function createTextureProgram(gl) {
        const vertexSource = `#version 300 es\nlayout(location = 0) in vec2 aPosition;\nlayout(location = 1) in vec2 aTexCoord;\nuniform vec2 uWorldSize;\nout vec2 vTexCoord;\nvoid main() {\n  vec2 normalized = aPosition / uWorldSize;\n  vec2 clip = normalized * 2.0 - 1.0;\n  vTexCoord = aTexCoord;\n  gl_Position = vec4(clip, 0.0, 1.0);\n}`;
        const fragmentSource = `#version 300 es\nprecision mediump float;\nuniform sampler2D uSampler;\nin vec2 vTexCoord;\nout vec4 outColor;\nvoid main() {\n  outColor = texture(uSampler, vTexCoord);\n}`;
        const program = buildProgram(gl, vertexSource, fragmentSource);
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);
        gl.enableVertexAttribArray(1);
        gl.bindVertexArray(null);
        const uniforms = {
          uWorldSize: gl.getUniformLocation(program, 'uWorldSize'),
          uSampler: gl.getUniformLocation(program, 'uSampler')
        };
        return { program, vao, buffer, uniforms };
      }

      function createCircleGeometry(gl, segments) {
        const vertices = [];
        vertices.push(0, 0);
        for (let i = 0; i <= segments; i++) {
          const angle = (i / segments) * Math.PI * 2;
          vertices.push(Math.cos(angle), Math.sin(angle));
        }
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        return { buffer, count: vertices.length / 2 };
      }

      function buildProgram(gl, vertexSrc, fragmentSrc) {
        const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
        const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(program));
          throw new Error('Failed to link WebGL program');
        }
        return program;
      }

      function compileShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          throw new Error('Shader compile failed');
        }
        return shader;
      }

      function loadBoardTexture(src) {
        loadTexture(src)
          .then(info => {
            board.texture = info.texture;
            board.height = board.width * (info.height / info.width);
            clampBoardPosition(board);
            renderScene();
          })
          .catch(error => {
            console.warn('Unable to load board texture', error);
          });
      }

      function loadTexture(src) {
        return new Promise((resolve, reject) => {
          const image = new Image();
          image.src = src;
          image.onload = () => {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.bindTexture(gl.TEXTURE_2D, null);
            resolve({ texture, width: image.naturalWidth, height: image.naturalHeight });
          };
          image.onerror = () => reject(new Error('Failed to load texture.'));
        });
      }

      function setupBoardControls() {
        window.addEventListener('keydown', event => {
          if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'a', 'd', 'w', 's'].includes(event.key)) {
            board.pressedKeys.add(event.key.toLowerCase());
            event.preventDefault();
          }
        });

        window.addEventListener('keyup', event => {
          board.pressedKeys.delete(event.key.toLowerCase());
        });

        canvas.addEventListener('pointerdown', event => {
          if (board.locked) {
            return;
          }
          const { worldX, worldY } = screenToWorld(event.clientX, event.clientY);
          if (!pointInsideBoard(worldX, worldY, board)) {
            return;
          }
          board.pointerId = event.pointerId;
          board.offsetX = worldX - board.x;
          board.offsetY = worldY - board.y;
          canvas.setPointerCapture(board.pointerId);
          canvas.classList.add('board-dragging');
        });

        canvas.addEventListener('pointermove', event => {
          if (board.locked || board.pointerId === null || event.pointerId !== board.pointerId) {
            return;
          }
          const { worldX, worldY } = screenToWorld(event.clientX, event.clientY);
          setBoardPosition(worldX - board.offsetX, worldY - board.offsetY);
          renderScene();
        });

        const releasePointer = event => {
          if (board.pointerId === null || (event && event.pointerId !== board.pointerId)) {
            return;
          }
          try {
            canvas.releasePointerCapture(board.pointerId);
          } catch (error) {
            // ignore
          }
          board.pointerId = null;
          canvas.classList.remove('board-dragging');
        };

        canvas.addEventListener('pointerup', releasePointer);
        canvas.addEventListener('pointercancel', releasePointer);
        canvas.addEventListener('lostpointercapture', releasePointer);
      }

      function updateBoardFromKeys(dt) {
        if (board.locked || !board.pressedKeys.size) {
          return;
        }
        let dx = 0;
        let dy = 0;
        if (board.pressedKeys.has('arrowleft') || board.pressedKeys.has('a')) dx -= 1;
        if (board.pressedKeys.has('arrowright') || board.pressedKeys.has('d')) dx += 1;
        if (board.pressedKeys.has('arrowup') || board.pressedKeys.has('w')) dy += 1;
        if (board.pressedKeys.has('arrowdown') || board.pressedKeys.has('s')) dy -= 1;
        if (dx === 0 && dy === 0) {
          return;
        }
        const length = Math.hypot(dx, dy) || 1;
        dx = (dx / length) * board.speed * dt;
        dy = (dy / length) * board.speed * dt;
        setBoardPosition(board.x + dx, board.y + dy);
      }

      function handleBoardCollision(ball) {
        if (board.locked) {
          return;
        }
        const halfW = board.width / 2;
        const halfH = board.height / 2;
        const left = board.x - halfW;
        const right = board.x + halfW;
        const bottom = board.y - halfH;
        const top = board.y + halfH;

        if (
          ball.x + ball.radius <= left ||
          ball.x - ball.radius >= right ||
          ball.y + ball.radius <= bottom ||
          ball.y - ball.radius >= top
        ) {
          return;
        }

        const overlapLeft = right - (ball.x - ball.radius);
        const overlapRight = (ball.x + ball.radius) - left;
        const overlapBottom = (ball.y + ball.radius) - bottom;
        const overlapTop = top - (ball.y - ball.radius);
        const minOverlap = Math.min(overlapLeft, overlapRight, overlapBottom, overlapTop);
        const restitution = board.restitution;

        if (minOverlap === overlapLeft) {
          ball.x = right + ball.radius;
          ball.vx = Math.abs(ball.vx) * restitution;
        } else if (minOverlap === overlapRight) {
          ball.x = left - ball.radius;
          ball.vx = -Math.abs(ball.vx) * restitution;
        } else if (minOverlap === overlapTop) {
          ball.y = top + ball.radius;
          ball.vy = Math.abs(ball.vy) * restitution;
        } else {
          ball.y = bottom - ball.radius;
          ball.vy = -Math.abs(ball.vy) * restitution;
        }
      }

      function screenToWorld(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const xNorm = (clientX - rect.left) / rect.width;
        const yNorm = (clientY - rect.top) / rect.height;
        return {
          worldX: xNorm * worldWidth,
          worldY: (1 - yNorm) * worldHeight
        };
      }

      function setBoardPosition(x, y) {
        board.x = x;
        board.y = y;
        clampBoardPosition(board);
      }

      function clampBoardPosition(boardState) {
        const halfW = boardState.width / 2;
        const halfH = boardState.height / 2;
        const minX = halfW + boardState.padding;
        const maxX = worldWidth - halfW - boardState.padding;
        const minY = floorY + halfH + boardState.verticalPadding;
        const maxY = worldHeight - halfH - boardState.verticalPadding;
        boardState.x = Math.min(Math.max(boardState.x, minX), maxX);
        boardState.y = Math.min(Math.max(boardState.y, minY), maxY);
      }

      function pointInsideBoard(x, y, boardState) {
        const halfW = boardState.width / 2;
        const halfH = boardState.height / 2;
        return (
          x >= boardState.x - halfW &&
          x <= boardState.x + halfW &&
          y >= boardState.y - halfH &&
          y <= boardState.y + halfH
        );
      }
    })();
  </script>


</body>
</html>
