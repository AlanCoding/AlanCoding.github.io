<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Rapid Fire Free Throws</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #f2f6ff, #d7e1ff 55%, #a4b5ff);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem 1rem 3rem;
    }

    main {
      max-width: 960px;
      width: 100%;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(6px);
      border-radius: 18px;
      box-shadow: 0 24px 40px rgba(40, 52, 120, 0.25);
      padding: 2rem clamp(1rem, 3vw, 2.5rem) 3rem;
    }

    h1 {
      font-size: clamp(2.2rem, 3vw + 1rem, 3.2rem);
      text-align: center;
      margin-top: 0;
      letter-spacing: 0.04em;
      color: #293a7a;
      text-shadow: 0 6px 16px rgba(25, 40, 92, 0.35);
    }

    #hud {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 1rem 2rem;
      margin-bottom: 1.5rem;
      font-weight: 600;
      color: #1f2b5c;
    }

    #hud span {
      min-width: 140px;
      text-align: center;
      font-size: 1.05rem;
    }

    #shoot {
      appearance: none;
      border: none;
      padding: 0.85rem 2.4rem;
      border-radius: 999px;
      font-size: 1.1rem;
      background: linear-gradient(135deg, #ff782c, #ff4e4e);
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 18px 24px rgba(240, 80, 40, 0.3);
      transition: transform 0.18s ease, box-shadow 0.18s ease, filter 0.18s ease;
    }

    #shoot:disabled {
      cursor: not-allowed;
      filter: grayscale(40%);
      box-shadow: none;
      background: #ffb48d;
      color: rgba(255, 255, 255, 0.8);
    }

    #shoot:not(:disabled):hover {
      transform: translateY(-2px);
      box-shadow: 0 20px 28px rgba(240, 80, 40, 0.35);
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
      border: 2px solid rgba(25, 40, 92, 0.15);
      background: linear-gradient(#9acbff, #87b7ff);
    }

    #controls {
      display: grid;
      gap: 0.8rem 1.2rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      margin-bottom: 1.4rem;
      color: #1f2b5c;
      font-weight: 600;
    }

    #controls label {
      display: grid;
      gap: 0.35rem;
      font-size: 0.95rem;
      padding: 0.9rem 1rem;
      border-radius: 12px;
      background: rgba(71, 92, 156, 0.08);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    #controls input[type="range"] {
      width: 100%;
      accent-color: #ff6c3c;
    }

    #controls span {
      font-size: 0.9rem;
      color: #293a7a;
    }

    p {
      margin-top: 1.75rem;
      line-height: 1.6;
      color: #2b3570;
      text-align: center;
    }
  </style>
</head>
<body>
  <main>
    <h1>Rapid Fire Free Throws</h1>
    <div id="hud">
      <span id="score">Score: 0</span>
      <span id="balls">Balls in play: 0</span>
      <span id="timer">Timer: 0.0s</span>
      <button id="shoot">Start Shooting</button>
    </div>
    <div id="controls">
      <label for="angle-control">
        Angle boost
        <input type="range" id="angle-control" min="-0.25" max="0.55" step="0.01" value="0.18" />
        <span id="angle-display">+10.3°</span>
      </label>
      <label for="power-control">
        Launch power
        <input type="range" id="power-control" min="14" max="26" step="0.1" value="19.5" />
        <span id="power-display">19.5 u/s</span>
      </label>
    </div>
    <canvas id="court" width="960" height="540"></canvas>
    <p>Unleash a cascade of free throws! Hit the button to fire 20 balls a second for ten straight seconds. Shots ricochet off the floor, the wall, and even each other. Sink them through the hoop before time runs out.</p>
  </main>
  <script>
    (() => {
      const canvas = document.getElementById('court');
      const gl = canvas.getContext('webgl2');
      const hudScore = document.getElementById('score');
      const hudBalls = document.getElementById('balls');
      const hudTimer = document.getElementById('timer');
      const shootButton = document.getElementById('shoot');
      const angleSlider = document.getElementById('angle-control');
      const powerSlider = document.getElementById('power-control');
      const angleDisplay = document.getElementById('angle-display');
      const powerDisplay = document.getElementById('power-display');

      if (!gl) {
        shootButton.disabled = true;
        canvas.replaceWith(Object.assign(document.createElement('p'), {
          textContent: 'WebGL2 is required to run this demo. Please try a modern browser!'
        }));
        return;
      }

      const worldWidth = 28;
      const worldHeight = 16;
      const gravity = -24;
      const floorHeight = 0.85;
      const floorY = floorHeight;
      const hoop = {
        x: 23.5,
        y: 9.6,
        radius: 0.95,
        innerRatio: 0.68,
        color: [0.85, 0.1, 0.1, 1.0]
      };
      const spawn = { x: 5, y: floorY + 1.65 };
      const wallRestitution = 0.76;
      const ballRestitution = 0.84;
      const spawnInterval = 1000 / 20; // milliseconds between balls
      const ballRadius = 0.36;

      const balls = [];
      let score = 0;
      let shootStart = 0;
      let shootEnd = 0;
      let simulationEnd = 0;
      let lastSpawn = 0;
      let lastFrame = 0;
      let animationActive = false;

      const circleGeometry = createCircleGeometry(gl, 48);
      const circleProgram = createCircleProgram(gl, circleGeometry);
      const rectProgram = createRectProgram(gl);
      const instanceBuffer = gl.createBuffer();

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = Math.floor(canvas.clientWidth * dpr);
        const displayHeight = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
        }
      }

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      function resetGame() {
        balls.length = 0;
        score = 0;
        shootStart = performance.now();
        shootEnd = shootStart + 10000;
        simulationEnd = shootStart + 13000;
        lastSpawn = shootStart;
        lastFrame = shootStart;
        animationActive = true;
        shootButton.disabled = true;
        updateHud(shootStart);
      }

      function spawnBall(time) {
        const angleAdjustment = parseFloat(angleSlider.value);
        const baseSpeed = parseFloat(powerSlider.value);
        const angleOffset = (Math.random() - 0.5) * 0.24;
        const baseTargetX = hoop.x - spawn.x;
        const baseTargetY = (hoop.y + 1.1) - spawn.y;
        const baseAngle = Math.atan2(baseTargetY, baseTargetX) + angleAdjustment;
        const angle = baseAngle + angleOffset;
        const directionX = Math.cos(angle);
        const directionY = Math.sin(angle);
        const speed = baseSpeed + (Math.random() - 0.5) * 3.0;
        const newBall = {
          x: spawn.x + (Math.random() - 0.5) * 0.28,
          y: spawn.y + (Math.random() - 0.1) * 0.14,
          vx: directionX * speed + (Math.random() - 0.5) * 2.2,
          vy: directionY * speed + Math.random() * 1.4,
          radius: ballRadius * (0.95 + Math.random() * 0.1),
          active: true
        };
        balls.push(newBall);
        updateHud(time);
      }

      function updateHud(time) {
        hudScore.textContent = `Score: ${score}`;
        hudBalls.textContent = `Balls in play: ${balls.filter(b => b.active).length}`;
        const remaining = Math.max(0, (simulationEnd - time) / 1000);
        hudTimer.textContent = `Timer: ${remaining.toFixed(1)}s`;
      }

      function updateControls() {
        const angleValue = parseFloat(angleSlider.value);
        const powerValue = parseFloat(powerSlider.value);
        const angleDegrees = angleValue * (180 / Math.PI);
        const formattedAngle = `${angleDegrees >= 0 ? '+' : ''}${angleDegrees.toFixed(1)}°`;
        angleDisplay.textContent = formattedAngle;
        powerDisplay.textContent = `${powerValue.toFixed(1)} u/s`;
      }

      function updatePhysics(dt, now) {
        const activeBalls = balls.filter(b => b.active);
        for (const ball of activeBalls) {
          ball.vy += gravity * dt;
          ball.x += ball.vx * dt;
          ball.y += ball.vy * dt;

          if (ball.y - ball.radius < floorY) {
            ball.y = floorY + ball.radius;
            ball.vy = Math.abs(ball.vy) * wallRestitution;
            ball.vx *= 0.88;
          }
          const rightWall = worldWidth - 0.4;
          if (ball.x - ball.radius < 0.4) {
            ball.x = 0.4 + ball.radius;
            ball.vx = Math.abs(ball.vx) * wallRestitution;
          }
          if (ball.x + ball.radius > rightWall) {
            ball.x = rightWall - ball.radius;
            ball.vx = -Math.abs(ball.vx) * wallRestitution;
          }
          const ceiling = worldHeight - 0.3;
          if (ball.y + ball.radius > ceiling) {
            ball.y = ceiling - ball.radius;
            ball.vy = -Math.abs(ball.vy) * 0.65;
          }

          const dx = ball.x - hoop.x;
          const dy = ball.y - hoop.y;
          const distSq = dx * dx + dy * dy;
          if (distSq < (hoop.radius - ball.radius * 0.35) * (hoop.radius - ball.radius * 0.35)) {
            ball.active = false;
            score += 1;
          }

          if (
            now > simulationEnd &&
            Math.abs(ball.vx) < 0.35 &&
            Math.abs(ball.vy) < 0.35 &&
            ball.y - ball.radius <= floorY + 0.05
          ) {
            ball.active = false;
          }
        }

        // ball-ball collisions
        for (let i = 0; i < activeBalls.length; i++) {
          const a = activeBalls[i];
          for (let j = i + 1; j < activeBalls.length; j++) {
            const b = activeBalls[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const distSq = dx * dx + dy * dy;
            const minDist = a.radius + b.radius;
            if (distSq > minDist * minDist) continue;
            const distance = Math.sqrt(distSq) || minDist;
            const nx = dx / distance;
            const ny = dy / distance;
            const penetration = minDist - distance;
            const correction = penetration / 2;
            a.x -= nx * correction;
            a.y -= ny * correction;
            b.x += nx * correction;
            b.y += ny * correction;

            const rvx = b.vx - a.vx;
            const rvy = b.vy - a.vy;
            const velAlongNormal = rvx * nx + rvy * ny;
            if (velAlongNormal > 0) continue;
            const impulse = -(1 + ballRestitution) * velAlongNormal / 2;
            const impulseX = impulse * nx;
            const impulseY = impulse * ny;
            a.vx -= impulseX;
            a.vy -= impulseY;
            b.vx += impulseX;
            b.vy += impulseY;
          }
        }

        for (const ball of activeBalls) {
          ball.vx *= 0.999;
          ball.vy *= 0.999;
        }

        for (let i = balls.length - 1; i >= 0; i--) {
          if (!balls[i].active) {
            balls.splice(i, 1);
          }
        }

        updateHud(now);
      }

      function renderScene() {
        resizeCanvas();
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.54, 0.73, 0.95, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // floor
        drawRect(0, 0, worldWidth, floorHeight, [0.91, 0.6, 0.26, 1.0]);
        drawRect(0, Math.max(0, floorHeight - 0.16), worldWidth, 0.16, [0.75, 0.48, 0.2, 1.0]);
        // left wall
        drawRect(0, 0, 0.4, worldHeight, [0.82, 0.85, 0.92, 1]);
        // backboard & support
        drawRect(22.8, 7.8, 0.16, 4.2, [0.7, 0.7, 0.76, 1]);
        drawRect(22.96, 10.3, 0.7, 2.2, [0.96, 0.96, 0.98, 1]);
        drawRect(23.1, 10.55, 0.42, 1.7, [0.88, 0.9, 0.96, 1]);

        // hoop ring
        drawCircle(hoop.x, hoop.y, hoop.radius, hoop.innerRatio, hoop.color);

        // stick figure shooter (simple limbs)
        const playerFootY = floorY + 0.05;
        const playerBodyColor = [0.1, 0.18, 0.3, 1];
        drawRect(spawn.x - 1.3, playerFootY, 0.22, 1.35, playerBodyColor);
        drawRect(spawn.x - 0.88, playerFootY, 0.22, 1.32, playerBodyColor);
        const playerTorsoY = playerFootY + 1.28;
        drawRect(spawn.x - 1.28, playerTorsoY, 0.86, 1.18, playerBodyColor);
        drawRect(spawn.x - 1.68, playerTorsoY + 0.72, 0.72, 0.16, playerBodyColor);
        drawRect(spawn.x - 0.5, playerTorsoY + 0.62, 0.96, 0.16, playerBodyColor);
        drawCircle(spawn.x - 0.88, playerTorsoY + 1.65, 0.55, -1, [0.99, 0.89, 0.72, 1]);

        // balls
        if (balls.length) {
          const instanceData = new Float32Array(balls.length * 8);
          for (let i = 0; i < balls.length; i++) {
            const ball = balls[i];
            instanceData[i * 8 + 0] = ball.x;
            instanceData[i * 8 + 1] = ball.y;
            instanceData[i * 8 + 2] = ball.radius;
            instanceData[i * 8 + 3] = -1; // inner ratio for filled disc
            instanceData[i * 8 + 4] = 1.0;
            instanceData[i * 8 + 5] = 0.5;
            instanceData[i * 8 + 6] = 0.0;
            instanceData[i * 8 + 7] = 1.0;
          }
          gl.useProgram(circleProgram.program);
          gl.bindVertexArray(circleProgram.vao);
          gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.DYNAMIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 0);
          gl.vertexAttribDivisor(1, 1);
          gl.enableVertexAttribArray(2);
          gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 32, 8);
          gl.vertexAttribDivisor(2, 1);
          gl.enableVertexAttribArray(3);
          gl.vertexAttribPointer(3, 1, gl.FLOAT, false, 32, 12);
          gl.vertexAttribDivisor(3, 1);
          gl.enableVertexAttribArray(4);
          gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 32, 16);
          gl.vertexAttribDivisor(4, 1);
          gl.uniform2f(circleProgram.uniforms.uWorldSize, worldWidth, worldHeight);
          gl.drawArraysInstanced(gl.TRIANGLE_FAN, 0, circleGeometry.count, balls.length);
          gl.bindVertexArray(null);
        }
      }

      function drawCircle(x, y, radius, innerRatio, color) {
        gl.useProgram(circleProgram.program);
        gl.bindVertexArray(circleProgram.vao);
        const instance = new Float32Array([
          x,
          y,
          radius,
          innerRatio,
          color[0],
          color[1],
          color[2],
          color[3]
        ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, instance, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 0);
        gl.vertexAttribDivisor(1, 1);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 32, 8);
        gl.vertexAttribDivisor(2, 1);
        gl.enableVertexAttribArray(3);
        gl.vertexAttribPointer(3, 1, gl.FLOAT, false, 32, 12);
        gl.vertexAttribDivisor(3, 1);
        gl.enableVertexAttribArray(4);
        gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 32, 16);
        gl.vertexAttribDivisor(4, 1);
        gl.uniform2f(circleProgram.uniforms.uWorldSize, worldWidth, worldHeight);
        gl.drawArraysInstanced(gl.TRIANGLE_FAN, 0, circleGeometry.count, 1);
        gl.bindVertexArray(null);
      }

      function drawRect(x, y, width, height, color) {
        gl.useProgram(rectProgram.program);
        gl.bindVertexArray(rectProgram.vao);
        const vertices = new Float32Array([
          x, y,
          x + width, y,
          x, y + height,
          x + width, y,
          x + width, y + height,
          x, y + height
        ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, rectProgram.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        gl.uniform2f(rectProgram.uniforms.uWorldSize, worldWidth, worldHeight);
        gl.uniform4f(rectProgram.uniforms.uColor, color[0], color[1], color[2], color[3]);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.bindVertexArray(null);
      }

      function loop(now) {
        if (!animationActive) return;
        if (!lastFrame) lastFrame = now;
        const dt = Math.min(0.05, (now - lastFrame) / 1000);

        if (now < shootEnd) {
          while (lastSpawn <= now) {
            spawnBall(now);
            lastSpawn += spawnInterval;
          }
        }

        updatePhysics(dt, now);
        renderScene();
        lastFrame = now;

        if (now > simulationEnd && balls.length === 0) {
          animationActive = false;
          shootButton.disabled = false;
          updateHud(now);
          return;
        }
        requestAnimationFrame(loop);
      }

      shootButton.addEventListener('click', () => {
        resetGame();
        requestAnimationFrame(loop);
      });

      angleSlider.addEventListener('input', updateControls);
      powerSlider.addEventListener('input', updateControls);
      updateControls();

      function createCircleProgram(gl, geometry) {
        const vertexSource = `#version 300 es\nlayout(location = 0) in vec2 aVertex;\nlayout(location = 1) in vec2 aCenter;\nlayout(location = 2) in float aRadius;\nlayout(location = 3) in float aInnerRatio;\nlayout(location = 4) in vec4 aColor;\nuniform vec2 uWorldSize;\nout vec2 vLocal;\nout float vInnerRatio;\nout vec4 vColor;\nvoid main() {\n  vec2 worldPos = aCenter + aVertex * aRadius;\n  vec2 normalized = worldPos / uWorldSize;\n  vec2 clip = normalized * 2.0 - 1.0;\n  vLocal = aVertex;\n  vInnerRatio = aInnerRatio;\n  vColor = aColor;\n  gl_Position = vec4(clip, 0.0, 1.0);\n}`;
        const fragmentSource = `#version 300 es\nprecision highp float;\nin vec2 vLocal;\nin float vInnerRatio;\nin vec4 vColor;\nout vec4 outColor;\nvoid main() {\n  float dist = length(vLocal);\n  if (dist > 1.0) discard;\n  if (vInnerRatio >= 0.0 && dist < vInnerRatio) discard;\n  outColor = vColor;\n}`;
        const program = buildProgram(gl, vertexSource, fragmentSource);
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        gl.bindVertexArray(null);
        const uniforms = {
          uWorldSize: gl.getUniformLocation(program, 'uWorldSize')
        };
        return { program, vao, uniforms };
      }

      function createRectProgram(gl) {
        const vertexSource = `#version 300 es\nlayout(location = 0) in vec2 aPosition;\nuniform vec2 uWorldSize;\nvoid main() {\n  vec2 normalized = aPosition / uWorldSize;\n  vec2 clip = normalized * 2.0 - 1.0;\n  gl_Position = vec4(clip, 0.0, 1.0);\n}`;
        const fragmentSource = `#version 300 es\nprecision mediump float;\nuniform vec4 uColor;\nout vec4 outColor;\nvoid main() {\n  outColor = uColor;\n}`;
        const program = buildProgram(gl, vertexSource, fragmentSource);
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        gl.bindVertexArray(null);
        const uniforms = {
          uWorldSize: gl.getUniformLocation(program, 'uWorldSize'),
          uColor: gl.getUniformLocation(program, 'uColor')
        };
        return { program, vao, buffer, uniforms };
      }

      function createCircleGeometry(gl, segments) {
        const vertices = [];
        vertices.push(0, 0);
        for (let i = 0; i <= segments; i++) {
          const angle = (i / segments) * Math.PI * 2;
          vertices.push(Math.cos(angle), Math.sin(angle));
        }
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        return { buffer, count: vertices.length / 2 };
      }

      function buildProgram(gl, vertexSrc, fragmentSrc) {
        const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
        const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(program));
          throw new Error('Failed to link WebGL program');
        }
        return program;
      }

      function compileShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          throw new Error('Shader compile failed');
        }
        return shader;
      }
    })();
  </script>
</body>
</html>
